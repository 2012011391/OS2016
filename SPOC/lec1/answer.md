## v9-cpu相关题目
---

请分析em.c，并补充cpu.md中描述不够或错误的地方。

> 在v9-cpu中如何实现时钟中断的；

程序使用TIME指令设置 timeout，即触发超时的阈值，而timer变量作为计数器，当timer大于等于timeout的时候触发时钟中断。当timeout为0时不触发时钟中断。

另外，timer并不是每一条指令运行结束后增加1的，而是在运行一段时间（XPC进入下一个页）的时候直接增加 `delta` (4096)。

> v9-cpu指令，关键变量描述有误或不全的情况

不全的地方包括：

* ssp：系统栈指针
* usp：用户栈指针
* cycle：指令周期数
* xcycle：
* timer： 时钟中断计数器
* timeout： 时钟中断计数器阈值
* delta： 每次时钟计数器的增量

> 在v9-cpu中的跳转相关操作是如何实现的

对于条件跳转指令 `Branch` 系列，首先判断是否符合跳转条件，如果符合在PC上面加上操作数，再检查PC是否进入新的内存页以及PC是否合法。如果合法则继续从新PC处开始运行，如果不合法则抛出 `FIPAGE` 异常，进入异常处理过程。

对于 `JMP` 类指令，直接跳转即可，即将PC加上操作数，执行和Branch系列一样的检查。

对于 `JSR` 类指令，唯一不同的地方在于要保存当前的PC值再进行跳转。


> 在v9-cpu中如何设计相应指令，可有效实现函数调用与返回

v9-cpu已经提供了 `JSR` 和 `JSRA`指令，其在跳转前将PC保存。对于函数返回，只需要从栈中弹出PC的值即可。对于参数的传递，可以参考x86的方式，将参数依次压入栈中，在子函数中通过sp-8等方式访问栈即可。

> emhello/os0/os1等程序被加载到内存的哪个位置,其堆栈是如何设置的

先读取程序头的信息

```c
  read(f, &hdr, sizeof(hdr));
```

之后再将程序加载到内存的起始地址

```c
read(f, (void*)mem, st.st_size - sizeof(hdr))
```

栈从上往下生长，初始值 sp 为内存大小减去文件系统大小，即 `memsz - FS_SZ`

> 在v9-cpu中如何完成一次内存地址的读写的；在v9-cpu中如何实现分页机制；

如果要写入数据到一个内存地址 v ，

- 先在页表 tr 中查找 v 的虚页，若存在，则返回虚页的物理地址与页内偏移
- 若不存在，则进入 `rlook()` 中查找，如果通过两级页表找到PTE，用setpage访存

```c
if (!(p = tw[(v = xsp - tsp + (ir>>8)) >> 12]) && !(p = wlook(v))) 
    break; 
*(uint *) ((v ^ p) & -4) = a;
```
